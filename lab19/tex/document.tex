\documentclass[a4paper,12pt]{article}

\usepackage[T2A]{fontenc}			
\usepackage[utf8]{inputenc}			
\usepackage[english,russian]{babel}	

\usepackage[
bookmarks=true, colorlinks=true, unicode=true,
urlcolor=black,linkcolor=black, anchorcolor=black,
citecolor=black, menucolor=black, filecolor=black,
]{hyperref}

\usepackage{color}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{white}{\parbox{\textwidth}{#1#2#3}}}

\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{wasysym}

\usepackage[cache=false]{minted}

\usepackage{graphicx}
\usepackage{cmap}
\usepackage{indentfirst}

\usepackage{listings} 
\usepackage{fancyvrb}

\usepackage{geometry}
\geometry{left=2cm}
\geometry{right=1.5cm}
\geometry{top=1cm}
\geometry{bottom=2cm}

\usepackage{longtable}

\setlength{\parindent}{5ex}
\setlength{\parskip}{0.5em}

\usepackage{pgfplots}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\begin{document}
\lstset{ %
	language=C,                 % выбор языка для подсветки (здесь это С)
	basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}

% Титульный лист
\begin{figure}[h!]
	\begin{center}
		{\includegraphics[scale = 0.4]{titul.jpg}}
		\label{titul}
	\end{center}
\end{figure}

\vspace*{15mm} 

\huge
\begin{center}
	Дисциплина: <<Функциональное и логическое программирование>>
\end{center}
\vspace*{15mm} 	

\begin{center}
	Лабораторная работа №19
\end{center}

\vspace*{15mm} 	

\large
\begin{flushright}
	Студент: Левушкин И. К. \\
	Группа: ИУ7-62Б \\
	Преподаватели: Толпинская Н. Б., \\ Строганов Ю. В. \\
\end{flushright}

\vspace*{30mm}
\begin{center}
	Москва, 2020 г.  
\end{center}
\thispagestyle{empty}


\newpage

\section*{Цель работы}

Изучить способы организации, представления и обработки списков в программах на Prolog, методы создания эффективных рекурсивных программ обработки списков и порядок их реализации.

\section*{Задачи работы}

Приобрести навыки использования списков на Prolog, эффективного способа их обработки, организации и прядка работы соответствующих программ.

Изучить особенность использования переменных при обработке списков. Способ формирования и изменения резольвенты в этом случае и порядок формирования ответа. 

\section*{Задание}

{\bf Ответить на вопросы} (коротко):
\begin{enumerate}
	\item Что такое рекурсия? Как организуется хвостовая рекурсия в Prolog? Как можно организовать выход из рекурсии в Prolog?
	\item Какое первое состояние резольвенты?
	\item В каких пределах программы переменные уникальны? 
	\item В какой момент, и каким способом системе удается получить доступ к голове списка?
	\item Каково назначение использования алгоритма унификации?
	\item Каков  результат работы алгоритма унификации? 
	\item Как формируется новое состояние резольвенты?
	\item Как применяется подстановка, полученная с помощью алгоритма унификации – как глубоко?
	\item В каких случаях запускается механизм отката? 
	\item Когда останавливается работа системы? Как это определяется на формальном уровне?
\end{enumerate}


{\bf Используя хвостовую рекурсию, разработать эффективную программу, (\underline{комментируя назначение аргументов}), позволяющую}:
\begin{enumerate}
	\item Найти длину списка (по верхнему уровню);
	\item Найти сумму элементов числового списка 
	\item Найти сумму элементов числового списка, стоящих на нечетных позициях исходного списка (нумерация от 0) 
\end{enumerate}

Убедиться в правильности результатов

{\bf Для одного} из вариантов {\bf ВОПРОСА} и одного из {\bf заданий составить таблицу}, отражающую конкретный порядок работы системы:

Т.к. резольвента хранится в виде стека, то состояние резольвенты требуется отображать в столбик: \underline{вершина – сверху!} Новый шаг надо начинать с нового состояния резольвенты! Для каждого запуска алгоритма унификации, требуется указать № выбранного правила и дальнейшие действия – и почему.


{\bf Текст процедуры,      Вопрос:...}

\begin{center}
	\begin{longtable}[h!]{|p{0.05\linewidth}|p{0.25\linewidth}|p{ 0.3\linewidth}|p{ 0.3\linewidth}|}
		\hline
		{№ шага} & {Текущая
		
	резольвента

- ТР} & {ТЦ, выбираемые правила:

сравниваемые термы,

подстановка} & {Дальнейшие действия с 
			
комментариями}\\
		\hline
		{шаг1} & {...} & {...} & {...}\\
		\hline
		{...} & {...} & {...} & {...}\\
		\hline
		\label{m1}
	\end{longtable}
\end{center}

\newpage

\section*{Реализация программы: найти длину списка (по верхнему уровню)}

\begin{minted}{prolog}
domains

	lst = integer*
	count, sum = integer
predicates

	len_list(lst, count).
	len_list_help(lst, count Help, count Result).
clauses

	len_list_help([], Help, Help).
	len_list_help([_|T], Help, Answer) :- 
	Next_help = Help + 1, len_list_help(T, Next_help, Answer).
	
	len_list(List, Answer) :- len_list_help(List, 0, Answer).
\end{minted}

\subsection*{Порядок и особенности выполнения программы и формирования результата.}

В разделе domains необходимо объявить тип списка. Было решено сделать список целых чисел (integer*).

Чтобы организовать хвостовую рекурсию, необходимо ввести дополнительный параметр Help, который будет накапливать в себе результат (в данном примере - длину списка), а при выходе из рекурсии выполнить подстановку: Answer = Help.

Выход из рекурсии будет осуществляться с помошью правила len\_list\_help([], Help, Help), когда список будет пуст.

На очередном этапе рекурсии происходит увеличение Help на единицу и использование знания len\_list\_help в очередной раз с уже новыми параметрами: измененным Help и хвостом списка.

\subsection*{Тесты}

\textit{Пример 1:}

\begin{minted}{prolog}
goal
	len_list([1, 2], Answer).
%Вывод:
	Answer=2
	1 Solution
\end{minted}

\textit{Пример 2:}

\begin{minted}{prolog}
goal
	len_list([1], Answer).
%Вывод:
	Answer=1
	1 Solution
\end{minted}

\textit{Пример 3:}

\begin{minted}{prolog}
goal
	len_list([], Answer).
%Вывод:
	Answer=0
	1 Solution
\end{minted}

\textit{Порядок работы системы:}

\begin{center}
	\begin{longtable}[h!]{|p{0.05\linewidth}|p{0.25\linewidth}|p{ 0.3\linewidth}|p{ 0.3\linewidth}|}
		\hline
		{№ шага} & {Текущая
			
			резольвента
			
			- ТР} & {ТЦ, выбираемые правила:
			
			сравниваемые термы,
			
			подстановка} & {Дальнейшие действия с 
			
			комментариями}\\
		\hline
		{1} & {len\_list([], Answer).} & {ТЦ = len\_list([], Answer).
			
	Правило 1: Унификация невозможна (функторы len\_list и len\_list\_help не равны).} & { Возврат к ТЦ, метка переносится ниже.}\\
		\hline
		{2} & {len\_list([], Answer).} & {ТЦ = len\_list([], Answer).
		
	Правило 2:	Унификация невозможна (функторы len\_list и len\_list\_help не равны).} & { Возврат к ТЦ, метка переносится ниже.}\\
		\hline
		{3} & {len\_list([], Answer).} & {ТЦ = len\_list([], Answer).
	
Правило 3: [] = List, Answer = Answer успех (подобрано знание) => \{List = [], Answer = Answer\}.} & {Проверка тела правила 3: len\_list\_help([], 0, Answer).}\\
		\hline
		{4} & {len\_list\_help([], 0, Answer).} & {ТЦ = len\_list\_help([], 0, Answer).
		
		Поиск знания с начала базы знаний.
		
	 Правило 1: [] = [], 0 = Help, Answer = Help успех (подобрано знание) => \{[] = [], Help = 0, Answer = 0\}.} & {Пустое тело заменяет цель в резольвенте.}\\
		\hline
		{5} & {Пусто} & {успех - ответ - <<Answer = 0>>, метка на Правиле 1.} & {Отказ от найденного значения (откат), возврат к предыдущему состоянию резольвенты.}\\
		\hline
		{6} & {len\_list\_help([], 0, Answer).} & {ТЦ = len\_list\_help([], 0, Answer).
			
			Правило 2:	[] = [\_|T] унификация невозможна.} & {Возврат к ТЦ,  метка переносится ниже.}\\
		\hline
		{7} & {len\_list\_help([], 0, Answer).} & {ТЦ = len\_list\_help([], 0, Answer).
		
	Правило 3: Унификация невозможна (функторы len\_list\_help и len\_list не равны) => неудача.} & {Отказ от найденного значения (откат), возврат к предыдущему состоянию резольвенты - len\_list([], Answer). Метка в конце процедуры – других альтернатив нет => система завершает работу с единственным результатом – <<Answer = 0>>.}\\
		\hline
		\label{m2}
	\end{longtable}
\end{center}

\section*{Реализация программы: найти сумму элементов числового списка}

\begin{minted}{prolog}
domains

lst = integer*
count, sum = integer
predicates

sum_list(lst, sum).
sum_list_help(lst, sum Help, sum Answer).
clauses

sum_list_help([], Help, Help).
sum_list_help([H|T], Help, Answer) :-
Next_help = Help + H, sum_list_help(T, Next_help, Answer).

sum_list(List, Answer) :- sum_list_help(List, 0, Answer).
\end{minted}

\subsection*{Порядок и особенности выполнения программы и формирования результата.}

В разделе domains необходимо объявить тип списка (integer*).

Чтобы организовать хвостовую рекурсию, необходимо ввести дополнительный параметр Help, который будет накапливать в себе результат (в данном примере - сумму элементов списка), а при выходе из рекурсии выполнить подстановку: Answer = Help.

Выход из рекурсии будет осуществляться с помошью правила sum\_list\_help([], Help, Help), когда список будет пуст.

На очередном этапе рекурсии происходит увеличение Help на H (голову списка) и использование знания sum\_list\_help в очередной раз с уже новыми параметрами: измененным Help и хвостом списка.

\subsection*{Тесты}

\textit{Пример 1:}

\begin{minted}{prolog}
goal
	sum_list([1, 2, 0], Answer).
%Вывод:
	Answer=3
	1 Solution
\end{minted}

\textit{Пример 2:}

\begin{minted}{prolog}
goal
	sum_list([5], Answer).
%Вывод:
	Answer=5
	1 Solution
\end{minted}

\textit{Пример 3:}

\begin{minted}{prolog}
goal
	sum_list([], Answer).
%Вывод:
	Answer=0
	1 Solution
\end{minted}

\newpage

\section*{Реализация программы: найти сумму элементов числового списка, стоящих на нечетных позициях исходного списка (нумерация от 0)}

\begin{minted}{prolog}
domains

lst = integer*
count, sum = integer
predicates

sum_odd_list(lst, sum).
sum_odd_list_help(lst, sum Help, sum Answer).
clauses

sum_odd_list_help([], Help, Help).

sum_odd_list_help([_|[]], Help, Help) :-!.

sum_odd_list_help([_|T], Help, Answer) :-
T = [Next_H|Next_T], New_help = Help + Next_H, 
sum_odd_list_help(Next_T, New_help, Answer).

sum_odd_list(List, Answer) :- sum_odd_list_help(List, 0, Answer).
\end{minted}

\subsection*{Порядок и особенности выполнения программы и формирования результата.}

В разделе domains необходимо объявить тип списка (integer*).

Чтобы организовать хвостовую рекурсию, необходимо ввести дополнительный параметр Help, который будет накапливать в себе результат (в данном примере - сумму нечетных элементов списка), а при выходе из рекурсии выполнить подстановку: Answer = Help.

Выход из рекурсии будет осуществляться с помошью правила sum\_odd\_list\_help([], Help, Help), когда список будет пуст.

На очередном этапе рекурсии происходит увеличение Help на Next\_H (голову хвоста списка) и использование знания sum\_odd\_list\_help в очередной раз с уже новыми параметрами: измененным Help и хвостом хвоста списка.

Чтобы быть уверенным, что получится из списка выделить 2 элемента подряд, присутствует проверка на это: sum\_odd\_list\_help([\_|[]], Help, Help), которое будет выполнено, если в списке присутствует только один элемент.

\subsection*{Тесты}

\textit{Пример 1:}

\begin{minted}{prolog}
goal
	sum_odd_list([1, 2, 3], Answer).
%Вывод:
	Answer=2
	1 Solution
\end{minted}

\textit{Пример 2:}

\begin{minted}{prolog}
goal
	sum_odd_list([1, 2, 3, 4], Answer).
%Вывод:
	Answer=6
	1 Solution
\end{minted}

\textit{Пример 3:}

\begin{minted}{prolog}
goal
	sum_odd_list([4], Answer).
%Вывод:
	Answer=0
	1 Solution
\end{minted}

\textit{Пример 4:}

\begin{minted}{prolog}
goal
	sum_odd_list([], Answer).
%Вывод:
	Answer=0
	1 Solution
\end{minted}

\section*{Выводы}

Эффективность работы каждой программы достигается путем использования хвостовой рекурсии, вводя дополнительные параметры, накапливающие в себе результат.

\newpage

\section*{Ответы на вопросы}

\subsection*{1.	Что такое рекурсия? Как организуется хвостовая рекурсия в Prolog? Как можно организовать выход из рекурсии в Prolog?}

Рекурсия – это ссылка при описании объекта на описываемый объект.

Хвостовая рекурсия в Prolog - ссылка на знание, эту же процедуру, 
последняя в теле правила.

Пример оформления хвостовой рекурсии:
p(ar1, …, argN) :-  <выход из рекурсии>.
…
p :- t1, …,tk, p(arg11, …, argN1).

При организации выхода из рекурсии необходимо учитываьб, что система использует механизм отката, Следовательно требуется обеспечить, чтобы после выхода из рекурсии система не пробовала использовать вновь ниже лежащие правила (возможно используя отсечение).

\subsection*{2.	Какое первое состояние резольвенты?}

Если задан простой вопрос, то сначала он попадает в резольвенту.

\subsection*{3.	В каких пределах программы переменные уникальны? }

Переменные уникальны в пределах предложения.

Исключение – анонимные переменные – каждая такая переменная является отдельной сущностью и применяется, когда ее значение неважно для данного предложения.

\subsection*{4.	В какой момент, и каким способом системе удается получить доступ к голове списка?}

В Prolog существует более общий способ доступа к элементам списка. Для этого используется метод разбиения списка на начало и остаток. Начало списка – это группа первых элементов, не менее одного. Остаток списка – обязательно список (может быть пустой). Для разделения списка на начало, и остаток используется вертикальная черта (|) за последним элементом начала.

Если начало состоит из одного элемента, то получим: голову и хвост.

\subsection*{5.	Каково назначение использования алгоритма унификации?}

Назначение алгоритма унификации заключается в попарном сопоставлении термов и попытке построить для них общий пример. 

\subsection*{6.	Каков  результат работы алгоритма унификации? }

Результатом использования алгоритма унификации может быть успех или тупиковая ситуация (неудача).

\subsection*{7.	Как формируется новое состояние резольвенты?}

Новая резольвента образуется в два этапа:
\begin{enumerate}
	\item в текущей резольвенте выбирается одна из подцелей (по стековому принципу - верхняя) и для неё выполняется редукция - замена подцели на тело найденного (подобранного, если удалось) правила,
	\item затем, к полученной конъюнкции целей применяется подстановка, полученная как наибольший общий унификатор цели (выбранной) и заголовка сопоставленного с ней правила.
\end{enumerate}

\subsection*{8.	Как применяется подстановка, полученная с помощью алгоритма унификации – как глубоко?}

Применение подстановки ${x_1=t_1, …, x_n=t_n}$ заключается в замене каждого вхождения переменной $x_i$ на соответствующий терм $t_i$.

\subsection*{9.	В каких случаях запускается механизм отката? }

Механизм отката запускается, если возникла тупиковая ситуация (достигнут конец БЗ) либо резольвента пуста. В таких случаях происходит откат к предыдущему состоянию резольвенты.

\subsection*{10. Когда останавливается работа системы? Как это определяется на формальном уровне?}

\textit{Если все метки достигли конца БЗ, то использованы все знания БЗ – и следует остановка работы системы.}

Для обозначения точки возврата, система помечает выбранное ранее правило, что позволяет ей перейти к данной метке, и использовать другое, следующее из ниже лежащих знаний в БЗ (не делать повторов). И т.к. БЗ просматривается сверху вниз, то если будет выбрано другое знание для доказательства исходной цели, то метка будет перенесена ниже по тексту БЗ. Т.о. метки ползут вниз. Во время работы системы, некоторое правило может быть использовано несколько раз, тогда оно будет помечено несколькими метками. Первой смещается последняя поставленная метка. 
	
\end{document}