\documentclass[a4paper,12pt]{article}

\usepackage[T2A]{fontenc}			
\usepackage[utf8]{inputenc}			
\usepackage[english,russian]{babel}	

\usepackage[
bookmarks=true, colorlinks=true, unicode=true,
urlcolor=black,linkcolor=black, anchorcolor=black,
citecolor=black, menucolor=black, filecolor=black,
]{hyperref}

\usepackage{color}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{white}{\parbox{\textwidth}{#1#2#3}}}

\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{wasysym}

\usepackage[cache=false]{minted}

\usepackage{graphicx}
\usepackage{cmap}
\usepackage{indentfirst}

\usepackage{listings} 
\usepackage{fancyvrb}

\usepackage{geometry}
\geometry{left=2cm}
\geometry{right=1.5cm}
\geometry{top=1cm}
\geometry{bottom=2cm}

\usepackage{longtable}

\setlength{\parindent}{5ex}
\setlength{\parskip}{0.5em}

\usepackage{pgfplots}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\begin{document}
	\lstset{ %
		language=C,                 % выбор языка для подсветки (здесь это С)
		basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
		numbers=left,               % где поставить нумерацию строк (слева\справа)
		numberstyle=\tiny,           % размер шрифта для номеров строк
		stepnumber=1,                   % размер шага между двумя номерами строк
		numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
		backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
		showspaces=false,            % показывать или нет пробелы специальными отступами
		showstringspaces=false,      % показывать или нет пробелы в строках
		showtabs=false,             % показывать или нет табуляцию в строках
		frame=single,              % рисовать рамку вокруг кода
		tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
		captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
		breaklines=true,           % автоматически переносить строки (да\нет)
		breakatwhitespace=false, % переносить строки только если есть пробел
		escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
	}

	% Титульный лист
	\begin{figure}[h!]
		\begin{center}
			{\includegraphics[scale = 0.4]{titul.jpg}}
			\label{titul}
		\end{center}
	\end{figure}
	
	\vspace*{15mm} 
	
	\huge
	\begin{center}
		Дисциплина: <<Функциональное и логическое программирование>>
	\end{center}
	\vspace*{15mm} 	
	
	\begin{center}
		Исправление ошибок 17, 18, 20 лабораторных работ
	\end{center}
	
	\vspace*{15mm} 	
	
	\large
	\begin{flushright}
		Студент: Левушкин И. К. \\
		Группа: ИУ7-62Б \\
		Преподаватели: Толпинская Н. Б., \\ Строганов Ю. В. \\
	\end{flushright}
	
	\vspace*{30mm}
	\begin{center}
		Москва, 2020 г.  
	\end{center}
	\thispagestyle{empty}
	
	\newpage
	
	
	\section*{Исправление ошибок по 17-ой лабораторной работе}
	
	\subsection*{Замечание}
	
	\textit{Табл  шаг8:}
	
	\textit{Знак = имеет смысл присвоения,  в Prolog такого нет!!! поскольку с одной из сторон от знака стоит свободная переменная. Подстановка Result = 2.}
	
	\textit{Вывод:}
	
	\textit{Result = 2. Откат к предыдущему	состоянию резольвенты: На каком основании??,}
	
	\textit{max\_three(2,	2,	2,
	Result),	Реконкретизация 2, 2, 2, Result. И почему конец? на след шаге?}
	
	\subsubsection*{Исправленная таблица}
	
	\begin{center}
		\begin{longtable}[h!]{|p{0.05\linewidth}|p{0.25\linewidth}|p{ 0.3\linewidth}|p{ 0.3\linewidth}|}
			
			\hline
			
			{№ шага} & {Состояние 
				
				
				
				резольвенты, и 
				
				
				
				вывод: дальнейшие 
				
				
				
				действия (почему?)} & {Для каких термов 
				
				
				
				запускается алгоритм 
				
				
				
				унификации: Т1=Т2 и 
				
				
				
				каков {\bf результат} (и 
				
				
				
				подстановка)} & {Дальнейшие действия: 
				
				
				
				прямой ход или откат 
				
				
				
				(почему и к чему 
				
				
				
				приводит?)}\\
			
			\hline
			
			{1} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);
				
				
				
				T2 = max\_two(Num1, Num2, Num1). 
				
				
				
				Неудача (функторы max\_three и max\_two не равны).} & {Прямой ход к следующему предложению.}\\
			
			\hline
			
			{2} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);
				
				
				
				T2 = max\_two(\_, Num2, Num2). Неудача (функторы max\_three и max\_two не равны).} & {Прямой ход к следующему преложению.}\\
			
			\hline
			
			{3} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);
				
				
				
				T2 = max\_three(Num1, Num2, Num3, Num1).
				
				
				
				Успех. Подстановка 2 = Num1, 2 = Num2, 2 = Num3, Result = Num1.} & {Прямой ход к 2 > 2.}\\
			
			\hline
			
			{4} & {2 > 2,
				
				
				
				2 > 2,
				
				
				
				Result = 2,
				
				!.} & {T1 = 2 > 2.
				
				Знак > имеет смысл сравнения, поскольку с обеих сторон от знака находятся конкретные значения. Неудача (2 !> 2).} & {Откат к предыдущему состоянию резольвенты: 
				
				max\_three(2, 2, 2, Result), Реконкретизация 2, 2, 2, Result.}\\
			\hline
			{5} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);
				
				T2 = max\_three(\_, Num2, Num3, Num2).
				
				Успех. Подстановка 2 = Num2, 2 = Num3, Result = Num2.} & {Прямой ход к 2 > 2.}\\
			\hline
			{6} & {2 > 2,
				
				Result = 2,
				
				!.} & {T1 = 2 > 2.
				
				Знак > имеет смысл сравнения, поскольку с обеих сторон от знака находятся конкретные значения. Неудача (2 !> 2).} & {Нет альтернативных путей унификации цели.
				
				Откат к предыдущему состоянию резольвенты: 
				
				max\_three(2, 2, 2, Result), Реконкретизация 2, 2, Result.}\\
			
			\hline
			
			{7} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);
				
				
				
				T2 = max\_three(\_, \_, Num3, Num3).
				
				
				
				Успех. Подстановка 2 = Num3, Result = Num3.} & {Прямой ход к Result = 2.}\\
			
			\hline
			
			{8} & {Result = 2.} & {T1 = Result = 2.
				
				Знак = имеет смысл конкретизации переменной Result.
				
				Подстановка Result = 2.} & {Вывод:
				
				
				
				Result = 2. Нет альтернативных путей унификации цели. Откат к предыдущему состоянию резольвенты:
				
				max\_three(2, 2, 2, Result), Реконкретизация 2, 2, 2, Result.}\\
			
			\hline
			
			{9} & {max\_three(2, 2, 2, Result).
				
				
				
				конец clauses,
				
				нет альтернативных путей унификации цели,
				
				откат к предыдущему состоянию резольвенты. Резольвента пуста =>
				
				завершение работы.} & {} & {}\\
			
			\hline
			\label{m1}
		\end{longtable}
	\end{center}

	\subsection*{Замечание}
	
	\textit{Назначение использования алгоритма унификации двух термов состоит в том, чтобы подобрать нужное в данный момент правило}
	
	\textit{Правило – это предложение, а сравниваются термы. – в материалах это есть!!}
	
	\textit{Для подбора ЗНАНИЯ (оно же в заголовке?!)  Вы в 18 в таблице пишете: (подобрано знание) а в ответе?}

	\subsubsection*{Исправление}
	
	Назначение использования алгоритма унификации двух термов состоит в том, чтобы подобрать нужное в данный момент знание.
	
	\section*{Исправление ошибок по 18-ой лабораторной работе}
	
	\subsection*{Замечание}
	
	\textit{В табл 4ш:Удаление из памяти альтернативных путей унификации цели Успех, А ВЫ думаете они храняться , а как их система находит?}
	
	\textit{У Вас превратное впечатление, что многое происходит само собой!} 
	
	\textit{Вы пишете:Других альтернатив нет , а как  система это понимает?        ОТВЕТТЕ!}
	
	\subsubsection*{Ответ}
	
	Знания по умолчанию просматриваются сверху вниз, и, соответственно, когда метка находится в конце Базы Знаний, система понимает, что альтернативных путей унификации цели нет.
	
	Поскольку в лекции №2 говорилось, что предекат отсечения ! (cut) <<отсекает в определенном случае бесперспективные пути доказательства>>, предположу, что он переводит метку в конец Базы Знаний. Таким образом, система поймет, что альтернативных путей унификации цели нет и выполнит откат к предыдущему состоянию резольвенты.
	
	
	\section*{Исправление ошибок по 20-ой лабораторной работе}
	
	\subsection*{Замечание}
	
	\textit{Предикат отсечения нужен во 2-ом правиле, чтобы отсечь бесперспективный путь доказательства, в данном случае это 3-е правило list\_create([\_|T], Number, T2), поскольку если элемент списка больше заданного значения, необходимо добавить его в результирующий список, применив правило 2, а третье правило служит для тех случаев, когда элемент списка не больше заданного значения, соответственно, применять 3-е правило, если 2-е правило успешно, не нужно.}
	
	\textit{В противном же случае, мы получим несколько решений, вместо одного необходимого.}
	
	\textit{А как ВЫ получите много рез-тов? Вы уйдете в рекурсию, и до ! дойдете только с пустым!!! Списком, а если Вы с ним попадете на 3-е правило, то разбить на части список не удастся – выход СОГЛАСНЫ?}
	
	
	\subsubsection*{Ответ}
	
	Согласен, но не совсем. Да, действительно, когда мы с пустым списком попадаем на 3-е правило, разбить на части список не удастся, но система выполнит откат лишь до предыдущего состояния резольвенты, и дальше продолжит искать альтернативные варианты, а не завершит работу. Чтобы объяснить, как я получу много результатов, приведу порядок работы системы на следующему примере:
	
	\textit{Текст программы без предиката !}
	
	\begin{minted}{prolog}
domains
	
	lstI = integer*
	number = integer
predicates
	
	list_create(lstI, number, lstI)
clauses
	list_create([], _, []).
	
	list_create([H|T], Number, [H|T2]) :-
	H > Number, list_create(T, Number, T2).
	
	list_create([_|T], Number, T2) :-
	list_create(T, Number, T2).
	
goal
	list_create([1, 2, 3], 2, Result)
	\end{minted}
	
	\textit{Порядок работы системы:}
	
	\begin{center}
		\begin{longtable}[h!]{|p{0.05\linewidth}|p{0.25\linewidth}|p{ 0.3\linewidth}|p{ 0.3\linewidth}|}
			\hline
			{№ шага} & {Состояние 
				
				резольвенты, и 
				
				вывод: дальнейшие 
				
				действия (почему?)} & {Для каких термов 
				
				запускается алгоритм 
				
				унификации: Т1=Т2 и 
				
				каков {\bf результат} (и 
				
				подстановка)} & {Дальнейшие действия: 
				
				прямой ход или откат 
				
				(почему и к чему 
				
				приводит?)}\\
			\hline
			{1} & {list\_create([1, 2, 3], 2, Result)} & {T1 = list\_create([1, 2, 3], 2, Result);
			
		T2 = list\_create([[], \_, []]).
	
Неудача, [] не равно [1, 2, 3].} & {Прямой ход к следующему предложению.}\\
			\hline
			{2} & {list\_create([1, 2, 3], 2, Result)} & {T1 = list\_create([1, 2, 3], 2, Result);
			
		T2 = list\_create([H|T], Number, [H|T2]). 
		
		Успех (подобрано знание) => \{H = 1, T = [2, 3], 2 = Number, Result = [1|T2]\})} & {Проверка тела правила правила 2: 1 > 2, list\_create([2, 3], 2, T2).}\\
			\hline
			{3} & {1 > 2
			
		list\_create([2, 3], 2, T2)} & {T1 = 1 > 2.
	
Знак > имеет смысл сравнения поскольку с обеих сторон от зна- ка находятся конкрет- ные значения. Неудача (1 не больше 2).} & {Нет альтернативных путей унификации цели. Откат к предыдущему состоянию резольвенты: list\_create([1, 2, 3], 2, Result)}\\
			\hline
			{4} & {list\_create([1, 2, 3], 2, Result)} & {T1 = list\_create([1, 2, 3], 2, Result);
			
		T2 = list\_create([\_|T], Number, T2).
	
Успех (подобрано значение) => \{T = [2, 3], Number = 2, Result = T2\}.} & {Проверка тела правила 3: list\_create([2, 3], 2, Result). Поиск с начала предложений}\\
			\hline
			{5} & {list\_create([2, 3], 2, Result)} & {T1 = list\_create([2, 3], 2, Result);
			
		T2 = list\_create([], \_, []).
	
Неудача ([2, 3] не равно []).} & {Прямой ход к следующему предложению.}\\
			\hline
			{6} & {list\_create([2, 3], 2, Result)} & {T1 = list\_create([2, 3], 2, Result);
			
		T2 = list\_create([H|T], Number, [H|T2]).
		
		Успех (подобрано знание) => \{H = 2, T = [3],  Number = 2, Result = [2|T2]\}.} & {Проверка тела правила 2: 2 > 2, list\_create([3], 2, T2).}\\
			\hline
			{7} & {2 > 2
				
				list\_create([3], 2, T2)} & {T1 = 2 > 2.
				
				Знак > имеет смысл сравнения поскольку с обеих сторон от знака находятся конкретные значения. Неудача (2 не больше 2).} & {Нет альтернативных путей унификации цели. Откат к предыдущему состоянию резольвенты: list\_create([2, 3], 2, Result)}\\
			\hline
			{8} & {list\_create([2, 3], 2, Result)} & {T1 = list\_create([2, 3], 2, Result);
			
		T2 = list\_create([\_|T], Number, T2).
	
Успех (подобрано знание) => \{T = [3], Number = 2, Result = T2\}.} & {Проверка тела правила 3: list\_create([3], 2, Result).}\\
			\hline
			{9} & {list\_create([3], 2, Result)} & {T1 =  list\_create([3], 2, Result);
			
		T2 =  list\_create([], \_, []).
	
Неудача ([3] не равно []).} & {Прямой ход к следующему предложению.}\\
			\hline
			{10} & {list\_create([3], 2, Result)} & {T1 = list\_create([3], 2, Result);
			
		T2 = list\_create([H|T], Number, [H|T2]).
	
Успех (подобрано знание) => \{H = 3, T = [], Number = 2, Result = T2\}.} & {Проверка тела правила 2: 3 > 2, list\_create([], 2, Result).}\\
			\hline
			{11} & {3 > 2
			
		list\_create([], 2, Result)} & {T1 = 3 > 2.
	
Знак > имеет смысл сравнения поскольку с обеих сторон от знака находятся конкретные значения. Успех.} & {Прямой ход к list\_create([], 2, Result).}\\
			\hline
			{12} & {list\_create([], 2, Result)} & {T1 = list\_create([], 2, Result);
			
		T2 = list\_create([], \_, []).
	
Успех (подобрано знание) => \{[] = [], 2 = \_, Result = []\}.} & {Пустое тело заменяет цель в резольвенте.}\\
			\hline
			{13} & {Пусто} & {успех - ответ - <<Result = [3]>>, метка на правиле 1.} & {Нет альтернативных путей унификации цели. Откат к предыдущему состоянию резольвенты: list\_create([], 2, Result). Прямой ход к следующему предложению.}\\
			\hline
			{14} & {list\_create([], 2, Result)} & {T1 = list\_create([], 2, Result);
			
		T2 = list\_create([H|T], Number, [H|T2]).
	
Неудача ([] не равно [H|T]).} & {Прямой ход к следующему предложению.}\\
			\hline
			{15} & {list\_create([], 2, Result)} & {T1 = list\_create([], 2, Result);
			
		T2 = list\_create([\_|T], Number, T2).
	
Неудача ([] не равно [\_|T]).} & {Нет альтернативных путей унификации цели. Откат к предыдущему состоянию резольвенты: list\_create([3], 2, Result). Прямой ход к следующему предложению.}\\
			\hline
			{16} & {list\_create([3], 2, Result)} & {T1 = list\_create([3], 2, Result);
			
		T2 = list\_create([\_|T], Number, T2).
	
Успех (подобрано знание) => \{T = [], Number = 2, Result = T2\}.} & {Проверка правила 3: list\_create([], 2, Result).}\\
			\hline
			{17} & {list\_create([], 2, Result)} & {T1 = list\_create([], 2, Result);
			
		T2 = list\_create([], \_, []).
	
Успех (подобрано знание) => \{Result = []\}.} & {Пустое тело заменяет цель в резольвенте.}\\
			\hline
			{18} & {Пусто} & {успех - ответ - <<Result = []>>, метка на правиле 1.} & {Нет альтернативных путей унификации цели. Откат к предыдущему состоянию резольвенты: list\_create([], 2, Result). Прямой ход к следующему предложению.}\\
			\hline
			{...} & {...} & {...} & {...}\\
			\hline
			\label{m2}
		\end{longtable}
	\end{center}

	Отсюда видно, что результатов получается больше чем 1. Провел тестирование в программе, результат тот же.
	
	\subsection*{Замечание}
	
	\textit{список из элементов, стоящих на нечетных позициях: Выделяйте срвзу
		по два элемента! За один шаг можно выделить не только голову! А начало из 2-х элементов, ПОПРОБУЙТЕ,}
	
	\subsubsection*{Ответ}
	
	Извините, но тут какая-то ошибка, я же попробовал и прислал вам уже исправленный текст программы, где в заголовке третьего правила: odd\_list\_help([\_, Next\_H|T], Help, Answer) как раз и происходит выделение СРАЗУ головы и второго элемента списка.
	
	\textit{Текст программы:}
	
	\begin{minted}{prolog}
domains
	
	lstI = integer*
	number = integer
predicates
	
	odd_list_help(lstI, lstI, lstI)
	odd_list(lstI, lstI)
clauses
	
	odd_list_help([], Help, Help).
	
	odd_list_help([_|[]], Help, Help) :-!.
	
	odd_list_help([_, Next_H|T], Help, Answer) :-
	odd_list_help(T,  [Next_H|Help], Answer).
	
	odd_list(List, Answer) :- odd_list_help(List, [], Answer).
	\end{minted}
	
	\subsection*{Замечание}
	
	Зачем reverse? На след-ий шаг рекурсии уходит хвост, добавляйте в голову хвоста, и формируйте результат в заголовке правила!! Исправьте! Пришлите текст3-ей прогр-мы!
	
	\subsubsection*{Ответ}
	
	Да, я это осознал и в прошлый раз вам уже прислал исправленный вариант без reverse, где как раз и происходит добавление элемента в голову хвоста (аналогично примеру из 3 лекции с append). Поправьте, если я чего-то не понимаю.
	
	\begin{minted}{prolog}
domains

	lstI = integer*
	number = integer
predicates
	
	delete_elem_from_list(lstI, number, lstI)
clauses

	delete_elem_from_list([], _, []).
	
	delete_elem_from_list([H|T], Number, [H|T3]) :-
	H <> Number, delete_elem_from_list(T, Number, T3),!.
	
	delete_elem_from_list([_|T], Number, T3) :-
	delete_elem_from_list(T, Number, T3).
	\end{minted}

\end{document}