\documentclass[a4paper,12pt]{article}

\usepackage[T2A]{fontenc}			
\usepackage[utf8]{inputenc}			
\usepackage[english,russian]{babel}	

\usepackage[
bookmarks=true, colorlinks=true, unicode=true,
urlcolor=black,linkcolor=black, anchorcolor=black,
citecolor=black, menucolor=black, filecolor=black,
]{hyperref}

\usepackage{color}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{white}{\parbox{\textwidth}{#1#2#3}}}

\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{wasysym}

\usepackage[cache=false]{minted}

\usepackage{graphicx}
\usepackage{cmap}
\usepackage{indentfirst}

\usepackage{listings} 
\usepackage{fancyvrb}

\usepackage{geometry}
\geometry{left=2cm}
\geometry{right=1.5cm}
\geometry{top=1cm}
\geometry{bottom=2cm}

\usepackage{longtable}

\setlength{\parindent}{5ex}
\setlength{\parskip}{0.5em}

\usepackage{pgfplots}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\begin{document}
\lstset{ %
	language=C,                 % выбор языка для подсветки (здесь это С)
	basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}

% Титульный лист
\begin{figure}[h!]
	\begin{center}
		{\includegraphics[scale = 0.4]{titul.jpg}}
		\label{titul}
	\end{center}
\end{figure}

\vspace*{15mm} 

\huge
\begin{center}
	Дисциплина: <<Функциональное и логическое программирование>>
\end{center}
\vspace*{15mm} 	

\begin{center}
	Лабораторная работа №20
\end{center}

\vspace*{15mm} 	

\large
\begin{flushright}
	Студент: Левушкин И. К. \\
	Группа: ИУ7-62Б \\
	Преподаватели: Толпинская Н. Б., \\ Строганов Ю. В. \\
\end{flushright}

\vspace*{30mm}
\begin{center}
	Москва, 2020 г.  
\end{center}
\thispagestyle{empty}


\newpage

\section*{Цель работы}

Изучить способы формирования и модификации списков в Prolog, эффективные методы обработки списков и порядок реализации рекурсивных программ.

\section*{Задачи работы}

Приобрести навыки формирования и модификации списков на Prolog, эффективного способа их обработки, организации и прядка работы соответствующих программ.

Изучить особенность использования переменных при обработке списков. Способ формирования и изменения резольвенты в этом случае и порядок формирования ответа. 


\section*{Задание}

{\bf Ответить на вопросы} (коротко):
\begin{enumerate}
	\item Как организуется хвостовая рекурсия в Prolog? 
	\item Какое первое состояние резольвенты?
	\item Каким способом можно разделить список на части, какие, требования к частям?
	\item Как выделить за один шаг первые два подряд идущих элемента списка? Как выделить 1-й и 3-й элемент за один шаг?
	\item Как формируется новое состояние резольвенты?
	\item Когда останавливается работа системы? Как это определяется на формальном уровне?
\end{enumerate}
	
	{\bf Используя хвостовую рекурсию, разработать, \underline{комментируя аргументы}, эффективную программу, позволяющую}:
	
	\begin{enumerate}
		\item Сформировать список из элементов числового списка, больших заданного значения;
		\item Сформировать список из элементов, стоящих на нечетных позициях исходного списка (нумерация от 0);
		\item Удалить заданный элемент из списка (один или все вхождения);
		\item Преобразовать список в множество (можно использовать ранее разработанные процедуры).
	\end{enumerate}

	Убедиться в правильности результатов
	
	{\bf Для одного} из вариантов {\bf ВОПРОСА} и {\bf 1-ого задания  составить таблицу}, отражающую конкретный порядок работы системы:
	
	Т.к. резольвента хранится в виде стека, то состояние резольвенты требуется отображать в столбик: \underline{вершина – сверху!} Новый шаг надо начинать с нового состояния резольвенты! Для каждого запуска алгоритма унификации, требуется указать № выбранного правила и соответствующий вывод: успех или нет –и почему.
	


{\bf Текст процедуры,      Вопрос:...}

\begin{center}
	\begin{longtable}[h!]{|p{0.05\linewidth}|p{0.25\linewidth}|p{ 0.3\linewidth}|p{ 0.3\linewidth}|}
		\hline
		{№ шага} & {Текущая
		
	резольвента

- ТР} & {ТЦ, выбираемые правила:

сравниваемые термы,

подстановка} & {Дальнейшие действия с 
			
комментариями}\\
		\hline
		{шаг1} & {...} & {...} & {...}\\
		\hline
		{...} & {...} & {...} & {...}\\
		\hline
		\label{m1}
	\end{longtable}
\end{center}

\newpage

\section*{Реализация программы: сформировать список из элементов числового списка, больших заданного значения.}

\begin{minted}{prolog}
domains

	lstI = integer*
	number = integer
predicates

	list_create(lstI, number, lstI)
	list_create_help(lstI, number, lstI, lstI)
clauses

	list_create_help([], _, Help, Help).
	
	list_create_help([H|T], Number, Help, Answer) :-
	H > Number, !, list_create_help(T, Number, [H|Help], Answer).
	
	list_create_help([_|T], Number, Help, Answer) :-
	list_create_help(T, Number, Help, Answer).
	
	list_create(List, Number, Answer) :-
	list_create_help(List, Number, [], Answer).
\end{minted}

\subsection*{Порядок и особенности выполнения программы и формирования результата.}

В разделе domains необходимо объявить тип списка (integer*).

Чтобы организовать хвостовую рекурсию, необходимо ввести дополнительный параметр Help, который будет накапливать в себе результат (в данном примере - список из элементов, больших заданного значения), а при выходе из рекурсии выполнить подстановку: Answer = Help.

Выход из рекурсии будет осуществляться с помошью правила list\_create\_help([], \_, Help, Help), когда список будет пуст.

Рекурсию организуют следующие два правила: list\_create\_help([H|T], Number, Help, Answer) и list\_create\_help([\_|T], Number, Help, Answer). 

Первое из них выполняется в том случае, если очередной элемент списка больше заданного значения (H > Number), при этом второе правило не будет выполняться из-за предиката отсечения !.

И, соответственно, второе правило выполнится, когда первое не будет выполняться - H !> Number. Таким образом, элементы списка, которые больше заданного значения, и элементы, которые не больше заданного значения, обрабатываются по-разному (разными правилами).

Первое вставляет текущий элемент в голову результирующего списка, а второе - игнорирует его.

Стоит отметить, что поскольку элементы последовательно добавляются в голову результирующего списка, полученный результат будет перевернутый. Однако, в данном случае нас это не интересует, поскольку в задании заранее не обговаривался порядок, в котором должен был быть сформирован список.

\subsection*{Тесты}

\textit{Пример 1:}

\begin{minted}{prolog}
goal
	list_create([1,2,3,4,5,6,7,8,9], 5, Answer).
%Вывод:
	Answer=[9,8,7,6]
	1 Solution
\end{minted}

\textit{Пример 2:}

\begin{minted}{prolog}
goal
	list_create([1,2,3,4,5,6,7,8,9], 9, Answer).
%Вывод:
	Answer=[]
	1 Solution
\end{minted}

\textit{Пример 3:}

\begin{minted}{prolog}
goal
	list_create([], 0, Answer).
%Вывод:
	Answer=[]
	1 Solution
\end{minted}

\textit{Порядок работы системы:}

\begin{center}
	\begin{longtable}[h!]{|p{0.05\linewidth}|p{0.25\linewidth}|p{ 0.3\linewidth}|p{ 0.3\linewidth}|}
		\hline
		{№ шага} & {Текущая
			
			резольвента
			
			- ТР} & {ТЦ, выбираемые правила:
			
			сравниваемые термы,
			
			подстановка} & {Дальнейшие действия с 
			
			комментариями}\\
		\hline
		{1} & {list\_create([], 0, Answer).} & {ТЦ = list\_create([], 0, Answer).
		
	Правило 1: Унификация невозможна (функторы list\_create и list\_create\_help не равны).} & {Возврат к ТЦ, метка переносится ниже.}\\
		\hline
		{2} & {list\_create([], 0, Answer).} & {ТЦ = list\_create([], 0, Answer).
			
			Правило 2: Унификация невозможна (функторы list\_create и list\_create\_help не равны).} & {Возврат к ТЦ, метка переносится ниже.}\\
		\hline
		{3} & {list\_create([], 0, Answer).} & {ТЦ = list\_create([], 0, Answer).
			
			Правило 3: Унификация невозможна (функторы list\_create и list\_create\_help не равны).} & {Возврат к ТЦ, метка переносится ниже.}\\
		\hline
		{4} & {list\_create([], 0, Answer).} & {ТЦ = list\_create([], 0, Answer).
			
			Правило 4: [] = List, 0 = Number, Answer = Answer успех (подобрано знание) => \{List = [], Number = 0, Answer = Answer\}.} & {Проверка тела правила 4: list\_create\_help([], 0, [], Answer).}\\
		\hline
		{5} & {list\_create\_help([], 0, [], Answer).} & {ТЦ = list\_create\_help([], 0, [], Answer).
		
	Поиск знания с начала базы знаний.

Правило 1: [] = [], Help = [], Help = Answer успех (подобрано знание) => \{[] = [], Help = [], Help = Answer\}.} & {Пустое тело заменяет цель в резольвенте.}\\
		\hline
		{6} & {Пусто.} & {успех - ответ - <<Answer = []>>, метка на правиле 1.} & {Отказ от найденного значения (откат), возврат к предыдущему состоянию резольвенты.}\\
		\hline
		{7} & {list\_create\_help([], 0, [], Answer).} & {ТЦ = list\_create\_help([], 0, [], Answer).
		
	Правило 2: [] = [H|T] унификация невозможна.} & {Возврат к ТЦ, метка переносится ниже.}\\
		\hline
		{8} & {list\_create\_help([], 0, [], Answer).} & {ТЦ = list\_create\_help([], 0, [], Answer).
			
			Правило 3: [] = [\_|T] унификация невозможна.} & {Возврат к ТЦ, метка переносится ниже.}\\
		\hline
		{9} & {list\_create\_help([], 0, [], Answer).} & {ТЦ = list\_create\_help([], 0, [], Answer).
		
	Правило 4: Унификация невозможна (функторы list\_create\_help и list\_create не равны).} & {Отказ от найденного значения (откат), возврат к предыдущему состоянию резольвенты - list\_create([], 0, Answer). Метка в конце процедуры -  других альтернатив нет => система завершает работу с единственным результатом – <<Answer = []>>.}\\
		\hline
		\label{m2}
	\end{longtable}
\end{center}

\newpage

\section*{Реализация программы: сформировать список из элементов, стоящих на нечетных позициях исходного списка (нумерация от 0).}

\begin{minted}{prolog}
domains

	lstI = integer*
	number = integer
predicates

	odd_list_help(lstI, lstI, lstI)
	odd_list(lstI, lstI)
clauses

	odd_list_help([], Help, Help).
	
	odd_list_help([_|[]], Help, Help) :-!.
	
	odd_list_help([_|T], Help, Answer) :-
	T = [Next_H|Next_T], New_help = [Next_H|Help], 
	odd_list_help(Next_T, New_help, Answer).
	
	odd_list(List, Answer) :- odd_list_help(List, [], Answer).
\end{minted}

\subsection*{Порядок и особенности выполнения программы и формирования результата.}

В разделе domains необходимо объявить тип списка (integer*).

Чтобы организовать хвостовую рекурсию, необходимо ввести дополнительный параметр Help, который будет накапливать в себе результат (в данном примере - список из элементов, стоящих на нечетных позициях в исходном списке), а при выходе из рекурсии выполнить подстановку: Answer = Help.

Выход из рекурсии будет осуществляться с помошью правила odd\_list\_help([], \_, Help, Help), когда список будет пуст.

Рекурсию организует следующее правило: odd\_list\_help([\_|T], Help, Answer).

На очередном этапе рекурсии происходит выделение второго элемента списка и добавление его в голову результирующего списка (в New\_help), а затем использование знания odd\_list\_help со следующими параметрами: измененным Help - New\_help и хвостом хвоста списка.

Чтобы быть уверенным, что получится из списка выделить 2 элемента подряд, присутствует проверка на это: odd\_list\_help([\_|[]], Help, Help), которое будет выполнено, если в списке присутствует только один элемент.

Стоит отметить, что поскольку элементы последовательно добавляются в голову результирующего списка, полученный результат будет перевернутый. Однако, в данном случае нас это не интересует, поскольку в задании заранее не обговаривался порядок, в котором должен был быть сформирован список.

\subsection*{Тесты}

\textit{Пример 1:}

\begin{minted}{prolog}
goal
	odd_list([1,2,3,4,5,6,7,8,9], Answer).
%Вывод:
	Answer=[8,6,4,2]
	1 Solution
\end{minted}

\textit{Пример 2:}

\begin{minted}{prolog}
goal
	odd_list([1,2,3,4], Answer).
%Вывод:
	Answer=[4,2]
	1 Solution
\end{minted}

\textit{Пример 3:}

\begin{minted}{prolog}
goal
	odd_list([1], Answer).
%Вывод:
	Answer=[]
	1 Solution
\end{minted}

\textit{Пример 4:}

\begin{minted}{prolog}
goal
	odd_list([], Answer).
%Вывод:
	Answer=[]
	1 Solution
\end{minted}

\section*{Реализация программы: удалить заданный элемент из списка (один или все вхождения).}

\begin{minted}{prolog}
domains

	lstI = integer*
	number = integer
predicates

	reverse_help(lstI, lstI, lstI)
	reverse(lstI, lstI)
	delete_elem_from_list_help(lstI, number, lstI, lstI)
	delete_elem_from_list(lstI, number, lstI)
clauses

	reverse_help([], Help, Help).
	
	reverse_help([H|T], Help, Answer) :-
	reverse_help(T, [H|Help], Answer).
	
	reverse(List, Answer) :- reverse_help(List, [], Answer).
	
	delete_elem_from_list_help([], _, Help, Answer) :- 
	reverse(Help, Answer).
	
	delete_elem_from_list_help([H|T], Number, Help, Answer) :-
	H <> Number, !, 
	delete_elem_from_list_help(T, Number, [H|Help], Answer).
	
	delete_elem_from_list_help([_|T], Number, Help, Answer) :-
	delete_elem_from_list_help(T, Number, Help, Answer).
	
	delete_elem_from_list(List, Number, Answer) :- 
	delete_elem_from_list_help(List, Number, [], Answer).
\end{minted}

\subsection*{Порядок и особенности выполнения программы и формирования результата.}

В разделе domains необходимо объявить тип списка (integer*).

Чтобы организовать хвостовую рекурсию, необходимо ввести дополнительный параметр Help, который будет накапливать в себе результат (в данном примере - список из элементов, не равных заданному числу Number), а при выходе из рекурсии выполнить подстановку: Answer = Help.

Выход из рекурсии будет осуществляться с помошью правила delete\_elem\_from\_list\_help([], \_, Help, Answer), когда список будет пуст.

Рекурсию организуют следующие два правила: delete\_elem\_from\_list\_help([H|T], Number, Help, Answer) и delete\_elem\_from\_list\_help([\_|T], Number, Help, Answer). 

Первое из них выполняется в том случае, если очередной элемент списка не равен заданному значению (H <> Number), при этом второе правило не будет выполняться из-за предиката отсечения !.

И, соответственно, второе правило выполнится, когда первое не будет выполняться - H = Number. Таким образом, элементы списка, равные заданному значению, и элементы, неравные заданному значению, обрабатываются по-разному (разными правилами).

Первое вставляет текущий элемент в голову результирующего списка, а второе - игнорирует его.

Стоит отметить, что поскольку элементы последовательно добавляются в голову результирующего списка, полученный результат будет перевернутый. Поэтому, в правиле, предназначенном для выхода из рекурсии вызывается правило reverse(Help, Answer), которое переворачивает список.

\subsection*{Тесты}

\textit{Пример 1:}

\begin{minted}{prolog}
goal
	delete_elem_from_list([1,2,3,4,5,6,6,7,8,9], 6, Answer).
%Вывод:
	Answer=[1,2,3,4,5,7,8,9]
	1 Solution
\end{minted}

\textit{Пример 2:}

\begin{minted}{prolog}
goal
	delete_elem_from_list([1,2,3,4,5,7,8,9], 6, Answer).
%Вывод:
	Answer=[1,2,3,4,5,7,8,9]
	1 Solution
\end{minted}

\textit{Пример 3:}

\begin{minted}{prolog}
goal
	delete_elem_from_list([1, 1, 1], 1, Answer).
%Вывод:
	Answer=[]
	1 Solution
\end{minted}

\textit{Пример 4:}

\begin{minted}{prolog}
goal
	delete_elem_from_list([], 0, Answer).
%Вывод:
	Answer=[]
	1 Solution
\end{minted}

\section*{Реализация программы: преобразовать список в множество (можно использовать ранее разработанные процедуры).}

\begin{minted}{prolog}
domains

lstI = integer*
number = integer
predicates

	convert_list_to_set_help(lstI, lstI, lstI).
	convert_list_to_set(lstI, lstI).
clauses

	convert_list_to_set_help([], Help, Help).
	
	convert_list_to_set_help([H|T], Help, Answer) :-
	delete_elem_from_list(T, H, New_T),
	convert_list_to_set_help(New_T, [H|Help], Answer).
	
	convert_list_to_set(List, Answer) :-
	convert_list_to_set_help(List, [], Answer).
\end{minted}

\subsection*{Порядок и особенности выполнения программы и формирования результата.}

В разделе domains необходимо объявить тип списка (integer*).

Чтобы организовать хвостовую рекурсию, необходимо ввести дополнительный параметр Help, который будет накапливать в себе результат (в данном примере - множество элементов), а при выходе из рекурсии выполнить подстановку: Answer = Help.

Выход из рекурсии будет осуществляться с помошью правила convert\_list\_to\_set\_help([], Help, Help), когда список будет пуст.

Рекурсию организует следующее правило: convert\_list\_to\_set\_help([H|T], Help, Answer).

На очередном этапе рекурсии происходит выделение головы списка, удаление элементов, равных голове, из хвоста списка с помощью процедуры delete\_elem\_from\_list, а затем использование знания convert\_list\_to\_set\_help со следующими параметрами: новым хвостом New\_T и списком [H|Help].


Стоит отметить, что поскольку элементы последовательно добавляются в голову результирующего списка, полученный результат будет перевернутый. Однако, в данном случае нас это не интересует, поскольку в множестве порядок элементов не важен.

\subsection*{Тесты}

\textit{Пример 1:}

\begin{minted}{prolog}
goal
	convert_list_to_set([1,2,3,1,2,3,1,2,2,3,4,5,6], Answer).
%Вывод:
	Answer=[6,5,4,3,2,1]
	1 Solution
\end{minted}

\textit{Пример 2:}

\begin{minted}{prolog}
goal
	convert_list_to_set([1,1,1,1,1,1], Answer).
%Вывод:
	Answer=[1]
	1 Solution
\end{minted}

\textit{Пример 3:}

\begin{minted}{prolog}
goal
	convert_list_to_set([], Answer).
%Вывод:
	Answer=[]
	1 Solution
\end{minted}


\section*{Выводы}

Эффективность работы каждой программы достигается путем использования хвостовой рекурсии, вводя дополнительные параметры, накапливающие в себе результат.

\newpage

\section*{Ответы на вопросы}

\subsection*{1.	Как организуется хвостовая рекурсия в Prolog? }

Хвостовая рекурсия в Prolog - ссылка на знание, эту же процедуру, 
последняя в теле правила.

Пример оформления хвостовой рекурсии:
p(ar1, …, argN) :-  <выход из рекурсии>.
…
p :- t1, …,tk, p(arg11, …, argN1).

\subsection*{2.	Какое первое состояние резольвенты?}

Если задан простой вопрос, то сначала он попадает в резольвенту.

\subsection*{3.	Каким способом можно разделить список на части, какие, требования к частям?}

В Prolog существует более общий способ доступа к элементам списка. Для этого используется метод разбиения списка на начало и остаток. Начало списка – это группа первых элементов, не менее одного. Остаток списка – обязательно список (может быть пустой). Для разделения списка на начало, и остаток используется вертикальная черта (|) за последним элементом начала. Остаток это всегда один (простой или составной) терм. 

\subsection*{4.	Как выделить за один шаг первые два подряд идущих элемента списка? Как выделить 1-й и 3-й элемент за один шаг?}

Первые 2 подряд идущих элемента списка: Lst = [First, Second | \_], где First, Second - два первых элемента списка Lst.

1-ый и 3- элемент списка: Lst = [First, \_, Third|\_], где First, Second - 1-ый и 3-ий элементы списка Lst.

\subsection*{5.	 Как формируется новое состояние резольвенты?}

Новая резольвента образуется в два этапа:
\begin{enumerate}
	\item в текущей резольвенте выбирается одна из подцелей (по стековому принципу - верхняя) и для неё выполняется редукция - замена подцели на тело найденного (подобранного, если удалось) правила,
	\item затем, к полученной конъюнкции целей применяется подстановка, полученная как наибольший общий унификатор цели (выбранной) и заголовка сопоставленного с ней правила.
\end{enumerate}

\subsection*{6.	Когда останавливается работа системы? Как это определяется на формальном уровне?}


\textit{Если все метки достигли конца БЗ, то использованы все знания БЗ – и следует остановка работы системы.}

Для обозначения точки возврата, система помечает выбранное ранее правило, что позволяет ей перейти к данной метке, и использовать другое, следующее из ниже лежащих знаний в БЗ (не делать повторов). И т.к. БЗ просматривается сверху вниз, то если будет выбрано другое знание для доказательства исходной цели, то метка будет перенесена ниже по тексту БЗ. Т.о. метки ползут вниз. Во время работы системы, некоторое правило может быть использовано несколько раз, тогда оно будет помечено несколькими метками. Первой смещается последняя поставленная метка. 

\end{document}
