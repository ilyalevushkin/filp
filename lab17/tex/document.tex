\documentclass[a4paper,12pt]{article}

\usepackage[T2A]{fontenc}			
\usepackage[utf8]{inputenc}			
\usepackage[english,russian]{babel}	

\usepackage[
bookmarks=true, colorlinks=true, unicode=true,
urlcolor=black,linkcolor=black, anchorcolor=black,
citecolor=black, menucolor=black, filecolor=black,
]{hyperref}

\usepackage{color}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{white}{\parbox{\textwidth}{#1#2#3}}}

\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{wasysym}

\usepackage[cache=false]{minted}

\usepackage{graphicx}
\usepackage{cmap}
\usepackage{indentfirst}

\usepackage{listings} 
\usepackage{fancyvrb}

\usepackage{geometry}
\geometry{left=2cm}
\geometry{right=1.5cm}
\geometry{top=1cm}
\geometry{bottom=2cm}

\usepackage{longtable}

\setlength{\parindent}{5ex}
\setlength{\parskip}{0.5em}

\usepackage{pgfplots}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\begin{document}
	\lstset{ %
		language=C,                 % выбор языка для подсветки (здесь это С)
		basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
		numbers=left,               % где поставить нумерацию строк (слева\справа)
		numberstyle=\tiny,           % размер шрифта для номеров строк
		stepnumber=1,                   % размер шага между двумя номерами строк
		numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
		backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
		showspaces=false,            % показывать или нет пробелы специальными отступами
		showstringspaces=false,      % показывать или нет пробелы в строках
		showtabs=false,             % показывать или нет табуляцию в строках
		frame=single,              % рисовать рамку вокруг кода
		tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
		captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
		breaklines=true,           % автоматически переносить строки (да\нет)
		breakatwhitespace=false, % переносить строки только если есть пробел
		escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
	}
	
	% Титульный лист
	\begin{figure}[h!]
		\begin{center}
			{\includegraphics[scale = 0.4]{titul.jpg}}
			\label{titul}
		\end{center}
	\end{figure}
	
	\vspace*{15mm} 
	
	\huge
	\begin{center}
		Дисциплина: <<Функциональное и логическое программирование>>
	\end{center}
	\vspace*{15mm} 	
	
	\begin{center}
		Лабораторная работа №17
	\end{center}
	
	\vspace*{15mm} 	
	
	\large
	\begin{flushright}
		Студент: Левушкин И. К. \\
		Группа: ИУ7-62Б \\
		Преподаватели: Толпинская Н. Б., \\ Строганов Ю. В. \\
	\end{flushright}
	
	\vspace*{30mm}
	\begin{center}
		Москва, 2020 г.  
	\end{center}
	\thispagestyle{empty}
	
	
	\newpage
	
	\section*{Цель работы}
	
	Изучить способы организации эффективных программ на Prolog, особенности использования системных предикатов и порядок выполнения программ с их использованием.
	
	\section*{Задачи работы}
	
	Приобрести навыки эффективного описания предметной области с использованием фактов и правил.
	
	Изучить возможность использования системных предикатов в программе на Prolog, принципы и особенности порядка работы в этом случае. Способ формирования и изменения резольвенты в этом случае и порядок формирования ответа.
	
	
	\section*{Задание}
	
	{\bf Ответить на вопросы:}
	
	\begin{itemize}
		\item Какое первое состояние резольвенты?
		\item В каком случае система запускает алгоритм унификации? (т.е. Как эту необходимость на формальном уровне распознает система?)
		\item Каково назначение использования алгоритма унификации? 
		\item Каков  результат работы алгоритма унификации? 
		\item В каких пределах программы переменные уникальны? 
		\item Как применяется подстановка, полученная с помощью алгоритма унификации?
		\item Как изменяется резольвента?
		\item В каких случаях запускается механизм отката?
	\end{itemize}
	
	{\bf В одной программе написать правила, позволяющие найти}
	
	\begin{enumerate}
		\item Максимум из двух чисел
		
		\begin{enumerate}
			\item без использования отсечения,
			\item с использованием отсечения;
		\end{enumerate}
		\item Максимум из трех чисел
		
		\begin{enumerate}
			\item без использования отсечения,
			\item с использованием отсечения;
		\end{enumerate}

		Убедиться в правильности результатов.
		
		{\bf Для каждого случая пункта 2 обосновать необходимость всех условий тела.}
		
		{\bf Для одного} из вариантов {\bf ВОПРОСА} и каждого варианта {\bf задания 2 составить таблицу}, отражающую конкретный порядок работы системы: 
		Т.к. резольвента хранится в виде стека, то состояние резольвенты требуется отображать в столбик: \underline{вершина – сверху!} Новый шаг надо начинать с нового состояния резольвенты!
	\end{enumerate}
	
	{\bf Вопрос:...}
	
	
	\begin{center}
	
	\begin{longtable}[h!]{|p{0.05\linewidth}|p{0.25\linewidth}|p{ 0.3\linewidth}|p{ 0.3\linewidth}|}
	
		\hline
	
		{№ шага} & {Состояние 
	
			
	
			резольвенты, и 
	
			
	
			вывод: дальнейшие 
	
			
	
			действия (почему?)} & {Для каких термов 
	
			
	
			запускается алгоритм 
	
			
	
			унификации: Т1=Т2 и 
	
			
	
			каков {\bf результат} (и 
	
			
	
			подстановка)} & {Дальнейшие действия: 
	
			
	
			прямой ход или откат 
	
			
	
			(почему и к чему 
	
			
	
			приводит?)}\\
	
		\hline
	
		{1...} & {...} & {...} & {Комментарий, вывод...}\\
	
		\hline
	
		{...} & {...} & {...} & {...}\\
	
		\hline
	
		\label{m1}
	
	\end{longtable}
	
\end{center}


	\newpage

	

	\section*{Реализация программы без использования отсечения}

	

	\begin{minted}{prolog}

domains
	num1, num2, num3, result = integer
predicates
	max_two(num1, num2, result).
	max_three(num1, num2, num3, result).
clauses
	max_two(Num1, Num2, Num1) :- Num2 <= Num1.
	
	max_two(Num1, Num2, Num2) :- Num2 > Num1.
	
	max_three(Num1, Num2, Num3, Num1) :- Num1 >= Num2, Num1 >= Num3.
	
	max_three(Num1, Num2, Num3, Num2) :- Num2 > Num1, Num2 > Num3.
	
	max_three(Num1, Num2, Num3, Num3) :- Num3 >= Num2, Num3 > Num1.

	\end{minted}

	

	\subsection*{Обоснование необходимости всех условий тел из пункта 2.}

	

	Поскольку стоит задача найти максимум из трех чисел, то алгоритм нахождения максимума без использования механизма отсечения выглядит так:

	

	\begin{enumerate}

		\item Проверить, является ли первое число (\textit{Num1}) не меньше чем остальные 2 (>=). Если да, то вывести это число.

		\item Проверить, является ли второе число (\textit{Num2}) наибольшим (>). При этом необходимо учесть, что первое и вторые пункты алгоритма должны быть взаимоисключающими, поэтому во втором случае в знаках неравенства стоят строгие знаки. Если является, то вывести это число.

		\item Аналогично необходимо проверить, является ли третье число (\textit{Num3}) больше первого (>) и не меньше второго (>=). Такая расстановка знаков обусловлена все тем же смыслом, что и в пункте 2 (во втором пункте стоят строгие знаки неравенства => в третьем должны быть не строгие и, наоборот, с первым пунктом).

	\end{enumerate}

	

	\newpage

	

	\subsection*{Тесты}

	

	Ниже приведены примеры для задания 1.

	

	\textit{Пример 1:}

	

	\begin{minted}{prolog}
goal
	max_two(1, 2, Result).
%Вывод:
	Result=2
	1 Solution

	\end{minted}

	

	\textit{Пример 2:}

	

	
\begin{minted}{prolog}
goal
	max_two(2, 2, Result).
%Вывод:
	Result=2
	1 Solution

	\end{minted}

	

	\textit{Пример 3:}

	

	\begin{minted}{prolog}
goal
	max_two(2, 1, Result).
%Вывод:
	Result=2
	1 Solution

	\end{minted}

	

	
Ниже приведены примеры для задания 2.

	

	\textit{Пример 1:}

	

	\begin{minted}{prolog}

goal

	max_three(1, 2, 3, Result).

%Вывод:

	Result=3
	1 Solution

	\end{minted}

	

	\textit{Пример 2:}

	

	\begin{minted}{prolog}

goal

	max_three(1, 2, 2, Result).

%Вывод:

	Result=2
	1 Solution

	\end{minted}

	

	\textit{Пример 3:}

	

	\begin{minted}{prolog}

goal

	max_three(5, 2, 3, Result).

%Вывод:

	Result=5
	1 Solution

	\end{minted}

	

	
\textit{Пример 4:}

	

	\begin{minted}{prolog}

	goal

	max_three(2, 2, 2, Result).

	%Вывод:

	Result=2

	1 Solution

	\end{minted}

	

	\textit{Порядок работы системы:}

	

	\begin{center}

		\begin{longtable}[h!]{|p{0.05\linewidth}|p{0.25\linewidth}|p{ 0.3\linewidth}|p{ 0.3\linewidth}|}

			\hline

			{№ шага} & {Состояние 

				

				резольвенты, и 

				

				вывод: дальнейшие 

				

				действия (почему?)} & {Для каких термов 

				

				запускается алгоритм 

				

				унификации: Т1=Т2 и 

				

				каков {\bf результат} (и 

				

				подстановка)} & {Дальнейшие действия: 

				

				прямой ход или откат 

				

				(почему и к чему 

				

				приводит?)}\\

			\hline

			{1} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);

			

		T2 = max\_two(Num1, Num2, Result).

	

Неудача (функторы max\_three и max\_two не равны).} & {Прямой ход к следующему предложению. Аналогичная ситуация со следующем предложением. Прямой ход к следующему предложению.}\\

			\hline

			{3} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);

			

		T2 = max\_three(Num1, Num2, Num3, Result).

	

Успех. Подстановка 2 = Num1, 2 = Num2, 3 = Num3, Result = Result.} & {Прямой ход к 2>=2.}\\

			\hline

			{4} & {2>=2,

			2>=2,

		Result=2.} & {T1 = 2>=2.

	

Знак >= имеет смысл сравнения поскольку с обеих сторон от знака находятся конкретные значения. Успех.} & {Прямой ход к 2>=2.}\\

			\hline

			{5} & {2>=2,

				Result = 2.} & {Знак >= имеет смысл сравнения, поскольку с обеих сторон от знака находятся конкретные значения. Успех.} & {Прямой ход к Result = 2.}\\

			\hline

			{6} & {Result = 2.} & {Знак = имеет смысл присвоения, поскольку с одной из сторон от знака стоит свободная переменная. Подстановка Result = 2.} & {Вывод:

			Result = 2. Откат к предыдущему состоянию резольвенты : 

			

			2 >=2,

			

			Result = 2. Нет альтернативных путей унификации цели. Откат к предыдущему состоянию резольвенты: 

			

			2>=2,

			

			2>=2,

			

			Result = 2. Нет альтернативных путей унификации цели. Откат к предыдущему состоянию резольвенты:

			

			max\_three(2, 2, 2, Result). Реконкретизация Result, 2, 2, 2.}\\

			\hline

			{7} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);

			

		T2 = max\_three(Num1, Num2, Num3, Result).

	

Успех. Подстановка 2 = Num1, 2 = Num2, 2 = Num3, Result = Result.} & {Прямой ход к 2 > 2.}\\

			\hline

			{8} & {2 > 2,

			

		2 > 2,

	

Result = 2.} & {T1 = 2 > 2.

Знак > имеет смысл сравнения, поскольку с обеих сторон от знака находятся конкретные значения. Неудача (2 !>2).} & {Откат к предыдущему состоянию резольвенты:

max\_three(2, 2, 2, Result). Реконкретизация Result, 2, 2, 2.}\\
			{9} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);
			
		T2 = max\_three(Num1, Num2, Num3, Result). 
		
		Успех. Подстановка 2 = Num1, 2 = Num2, 2 = Num3, Result = Result.} & {Прямой ход к 2 >= 2.}\\

			\hline
			{10} & {2 >= 2,
			
		2 > 2,
	
Result = 2.} & {T1 = 2 >= 2.

Знак >= имеет смысл сравнения, поскольку с обеих сторон от знака находятся конкретные значения. Успех.} & {Прямой ход к 2 > 2.}\\
			\hline
			{11} & {2 > 2,
			
		Result = 2.} & {T1 = 2 > 2.
	
 Знак > имеет смысл сравнения, посколько с обеих сторон от знака находятся конкретные значения. Неудача (2 !> 2).} & {Откат к предыдущему состоянию резольвенты: 2 >= 2,

2 > 2,

Result = 2. Нет альтернативных путей унификации цели. Откат к предыдущему состоянию резольвенты: 

max\_three(2, 2, 2, Result). Реконкретизация Result, 2, 2, 2.}\\
			\hline
			{12} & {max\_three(2, 2, 2, Result).
			
		конец clauses,
	
опустошение резольвенты,

завершение работы.} & {} & {}\\
			\hline

			\label{m2}

		\end{longtable}

	\end{center}

	

	\section*{Реализация программы с использованием отсечения}

	

	\begin{minted}{prolog}

domains
	num1, num2, num3, result = integer
predicates
	max_two(num1, num2, result).
	max_three(num1, num2, num3, result).
clauses
	max_two(Num1, Num2, Num1) :-
	Num1 > Num2, !.
	
	max_two(_, Num2, Num2).
	
	
	max_three(Num1, Num2, Num3, Num1) :-
	Num1 > Num2, Num1 > Num3, !.
	
	max_three(_, Num2, Num3, Num2) :-
	Num2 > Num3, !.
	
	max_three(_, _, Num3, Num3).

	\end{minted}

	

	\subsection*{Обоснование необходимости всех условий тел из пункта 2.}

	

	Поскольку стоит задача найти максимум из трех чисел, то алгоритм нахождения максимума с использования механизма отсечения выглядит так:

	

	\begin{enumerate}

		\item Проверить, является ли первое число (\textit{Num1}) наибольшим (>). Если да, то вывести это число, и завершить поиск других решений с помощью предиката отсечения !.

		\item Аналогично проверить, является ли второе число (\textit{Num1}) больше третьего (>). При этом необходимость в проверке того, что второе число не меньше первого отпадает, поскольку это следует из того, что первое условие не выполнилось, иначе дальнейшая работа программы была бы прекращена предикатом !. Если да, то вывести это число, и завершить поиск других решений с помощью предиката отсечения !.

		\item Если же ни первое ни второе условия не выполнились, то значит, что ни первое и ни второе числа не наибольшие. Значит наибольшее третье. Выводим третье число.

	\end{enumerate}

	

	\newpage

	

	\subsection*{Тесты}

	

	Тесты и их результаты полностью совпадают с тестами для реализации программы без использования отсечения.

	

	\textit{Порядок работы системы для 4 примера 2 задания:}

	

	\begin{center}

		\begin{longtable}[h!]{|p{0.05\linewidth}|p{0.25\linewidth}|p{ 0.3\linewidth}|p{ 0.3\linewidth}|}

			\hline

			{№ шага} & {Состояние 

				

				резольвенты, и 

				

				вывод: дальнейшие 

				

				действия (почему?)} & {Для каких термов 

				

				запускается алгоритм 

				

				унификации: Т1=Т2 и 

				

				каков {\bf результат} (и 

				

				подстановка)} & {Дальнейшие действия: 

				

				прямой ход или откат 

				

				(почему и к чему 

				

				приводит?)}\\

			\hline

			{1} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);

			

		T2 = max\_two(Num1, Num2, Result). 

		

		Неудача (функторы max\_three и max\_two не равны).} & {Прямой ход к следующему предложению.}\\

			\hline

			{2} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);

			

		T2 = max\_two(\_, Num2, Result). Неудача (функторы max\_three и max\_two не равны).} & {Прямой ход к следующему преложению.}\\

			\hline

			{3} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);

			

		T2 = max\_three(Num1, Num2, Num3, Result).

	

Успех. Подстановка 2 = Num1, 2 = Num2, 2 = Num3, Result = Result.} & {Прямой ход к 2 > 2.}\\

			\hline

			{4} & {2 > 2,

			

		2 > 2,

	

Result = 2,

!.} & {T1 = 2 > 2.

Знак > имеет смысл сравнения, поскольку с обеих сторон от знака находятся конкретные значения. Неудача (2 !> 2).} & {Откат к предыдущему состоянию резольвенты: 

max\_three(2, 2, 2, Result), Реконкретизация 2, 2, 2, Result.}\\
			\hline
			{5} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);
				
				T2 = max\_three(\_, Num2, Num3, Result).
				
				Успех. Подстановка 2 = Num2, 2 = Num3, Result = Result.} & {Прямой ход к 2 > 2.}\\
			\hline
			{6} & {2 > 2,
				
				Result = 2,
				
				!.} & {T1 = 2 > 2.
				
				Знак > имеет смысл сравнения, поскольку с обеих сторон от знака находятся конкретные значения. Неудача (2 !> 2).} & {Откат к предыдущему состоянию резольвенты: 
				
				max\_three(2, 2, 2, Result), Реконкретизация 2, 2, Result.}\\

			\hline

			{7} & {max\_three(2, 2, 2, Result).} & {T1 = max\_three(2, 2, 2, Result);

			

		T2 = max\_three(\_, \_, Num3, Result).

	

Успех. Подстановка 2 = Num3, Result = Result.} & {Прямой ход к Result = 2.}\\

			\hline

			{8} & {Result = 2.} & {T1 = Result = 2.

			

		Знак = имеет смысл присвоения, поскольку с одной из сторон от знака стоит свободная переменная. Подстановка Result = 2.} & {Вывод:

	

Result = 2. Откат к предыдущему состоянию резольвенты:

max\_three(2, 2, 2, Result), Реконкретизация 2, 2, 2, Result.}\\

			\hline

			{9} & {max\_three(2, 2, 2, Result).

				

			конец clauses,

		

	опустошение резольвенты,

завершение работы.} & {} & {}\\

			\hline

			\label{m3}

		\end{longtable}

	\end{center}


	\section*{Выводы}

	

	\textit{За счет чего может быть достигнута эффективность работы системы?}

	

	Из проделанной лабораторной работы можно сделать вывод, что эффективность работы системы может быть достигнута за счет использования специальных средств управления порядком работы системы, таким как предикат отсечения ! (cat), который позволяет отсекать в определенных случаях бесперспективные пути доказательства.

	

	Это и было продемонстировано при реализации 2 задания двумя способами: с использованием отсечения было затрачено 9 шагов на поиск решения, в то время как без использования отсечения было затрачено 12 шагов.

	

	\newpage

	

	\section*{Ответы на вопросы}

	

	\subsection*{Какое первое состояние резольвенты?}

	

	Если задан простой вопрос, то сначала он попадает в резольвенту.

	

	\subsection*{В каком случае система запускает алгоритм унификации? (т.е. Как эту необходимость на формальном уровне распознает система?)}

	

	Процесс унификации запускается, если есть цель, которую необходимо доказать (формально: если резольвента не пуста).

	

	\subsection*{Каково назначение использования алгоритма унификации? }

	

	Назначение алгоритма унификации заключается в попарном сопоставлении термов и попытке построить для них общий пример. 

	

	\subsection*{Каков результат работы алгоритма унификации? }

	

	Результатом использования алгоритма унификации может быть успех или тупиковая ситуация (неудача).

	

	\subsection*{В каких пределах программы переменные уникальны? }

	

	Переменные уникальны в пределах предложения.

	

	Исключение – анонимные переменные – каждая такая переменная является отдельной сущностью и применяется, когда ее значение неважно для данного предложения.

	

	\subsection*{Как применяется подстановка, полученная с помощью алгоритма унификации?}

	

	Применение подстановки ${x_1=t_1, …, x_n=t_n}$ заключается в замене каждого вхождения переменной $x_i$ на соответствующий терм $t_i$.

	

	\subsection*{Как изменяется резольвента?}

	

	Состояние резольвенты меняется в процессе доказательства (для хранения резольвенты система использует стек). Преобразования резольвенты выполняются с помощью {\bf редукции}.

	

	{\bf Редукцией} цели G с помощью программы P называется замена цели G телом того правила из P, заголовок которого унифицируется с целью.

	

	\subsection*{В каких случаях запускается механизм отката?}
	
	Механизм отката запускается, если возникла тупиковая ситуация (достигнут конец БЗ) либо резольвента пуста. В таких случаях происходит откат к предыдущему состоянию резольвенты.
	
\end{document}